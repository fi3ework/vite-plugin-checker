import { readFileSync } from 'fs'
import os from 'os'
import strip from 'strip-ansi'
import { ErrorPayload } from 'vite'
import chalk from 'chalk'

import { codeFrameColumns, SourceLocation } from '@babel/code-frame'

import { uriToAbsPath } from './utils'

// TODO: remove ./codeFrame.ts and ./utils.ts

import type {
  Diagnostic as TsDiagnostic,
  flattenDiagnosticMessageText as flattenDiagnosticMessageTextType,
  LineAndCharacter,
} from 'typescript'

interface NormalizedDiagnostic {
  /** error message */
  message?: string
  /** error conclusion */
  conclusion?: string
  /** error stack */
  stack?: string | string[]
  /** file name */
  id?: string
  /** checker diagnostic source */
  checker: string
  /** raw code frame generated by @babel/code-frame */
  codeFrame?: string
  /** code frame, but striped */
  stripedCodeFrame?: string
  /** error code location */
  loc?: SourceLocation
  /** error level */
  level?: 'error' | 'warning'
}

export function diagnosticToTerminalLog(d: NormalizedDiagnostic): string {
  const levelLabel =
    d.level === 'error'
      ? chalk.red.bold('ERROR') + ' '
      : d.level === 'warning'
      ? chalk.yellow.bold('WARNING') + ' '
      : ''
  const fileLabel = chalk.green.bold('FILE') + '  '
  return [levelLabel + d.message, fileLabel + d.id + os.EOL, d.codeFrame + os.EOL, d.conclusion]
    .filter(Boolean)
    .join(os.EOL)
}

export function diagnosticToViteError(d: NormalizedDiagnostic): ErrorPayload['err'] {
  let loc: ErrorPayload['err']['loc']
  if (d.loc) {
    loc = {
      file: d.id,
      line: d.loc.start.line + 1,
      column: typeof d.loc.start.column === 'number' ? d.loc.start.column + 1 : 0,
    }
  }

  return {
    message: d.message ?? '',
    stack:
      typeof d.stack === 'string' ? d.stack : Array.isArray(d.stack) ? d.stack.join(os.EOL) : '',
    id: d.id,
    frame: d.codeFrame,
    plugin: `vite-plugin-checker(${d.checker})`,
    loc,
  }
}

export function createFrame({
  source,
  location,
}: {
  /** file source code */
  source: string
  location: SourceLocation
}) {
  const frame = codeFrameColumns(source, location, {
    // worker tty did not fork parent process stdout, let's make a workaround
    forceColor: true,
  })
    .split('\n')
    .map((line) => '  ' + line)
    .join(os.EOL)

  return frame
}

export function tsLocationToBabelLocation(
  tsLoc: Record<'start' | 'end', LineAndCharacter /** 0-based */>
): SourceLocation {
  return {
    start: { line: tsLoc.start.line + 1, column: tsLoc.start.character + 1 },
    end: { line: tsLoc.end.line + 1, column: tsLoc.end.character + 1 },
  }
}

export function normalizeDiagnostic(d: TsDiagnostic): NormalizedDiagnostic {
  if (isTsDiagnostic(d)) return normalizeTsDiagnostic(d)
  throw Error(`unsupported diagnostic, only support TypeScript / VLS for now.`)
}

/* ------------------------------- TypeScript ------------------------------- */

export function isTsDiagnostic(d: any): d is TsDiagnostic {
  return (
    'category' in d &&
    'code' in d &&
    'file' in d &&
    'start' in d &&
    'length' in d &&
    'messageText' in d
  )
}

export function normalizeTsDiagnostic(d: TsDiagnostic): NormalizedDiagnostic {
  const fileName = d.file?.fileName
  const {
    flattenDiagnosticMessageText,
  }: {
    flattenDiagnosticMessageText: typeof flattenDiagnosticMessageTextType
  } = require('typescript')

  const message = flattenDiagnosticMessageText(d.messageText, os.EOL)

  let loc: SourceLocation | undefined
  const pos = d.start === undefined ? null : d.file?.getLineAndCharacterOfPosition(d.start)
  if (pos && d.file && typeof d.start === 'number' && typeof d.length === 'number') {
    loc = tsLocationToBabelLocation({
      start: d.file?.getLineAndCharacterOfPosition(d.start),
      end: d.file?.getLineAndCharacterOfPosition(d.start + d.length),
    })
  }

  let codeFrame: string | undefined
  if (loc) {
    codeFrame = createFrame({
      source: d.file!.text,
      location: loc,
    })
  }

  return {
    message,
    conclusion: '',
    codeFrame,
    stripedCodeFrame: codeFrame && strip(codeFrame),
    id: fileName,
    checker: 'TypeScript',
    loc,
    level: 'error',
  }
}

/* ----------------------------------- VLS ---------------------------------- */

/* --------------------------------- vue-tsc -------------------------------- */

/* --------------------------------- ESLint --------------------------------- */
